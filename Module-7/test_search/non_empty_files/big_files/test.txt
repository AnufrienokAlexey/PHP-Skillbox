Еще один файл с какими-то данными...


Массивы ¶
На самом деле массив в PHP - это упорядоченное отображение, которое устанавливает соответствие между значением и ключом. Этот тип оптимизирован в нескольких направлениях, поэтому вы можете использовать его как собственно массив, список (вектор), хеш-таблицу (являющуюся реализацией карты), словарь, коллекцию, стек, очередь и, возможно, что-то ещё. Так как значением массива может быть другой массив PHP, можно также создавать деревья и многомерные массивы.

Объяснение этих структур данных выходит за рамки данного справочного руководства, но вы найдёте как минимум один пример по каждой из них. За дополнительной информацией вы можете обратиться к соответствующей литературе по этой обширной теме.

Синтаксис ¶
Определение при помощи array() ¶
Массив (тип array) может быть создан языковой конструкцией array(). В качестве параметров она принимает любое количество разделённых запятыми пар key => value (ключ => значение).

array(
    key  => value,
    key2 => value2,
    key3 => value3,
    ...
)
Запятая после последнего элемента массива необязательна и может быть опущена. Обычно это делается для однострочных массивов, то есть array(1, 2) предпочтительней array(1, 2, ). Для многострочных массивов с другой стороны обычно используется завершающая запятая, так как позволяет легче добавлять новые элементы в конец массива.

Замечание:

Существует короткий синтаксис массива, который заменяет array() на [].

Пример #1 Простой массив

<?php
$array = array(
    "foo" => "bar",
    "bar" => "foo",
);

// Использование синтаксиса короткого массива
$array = [
    "foo" => "bar",
    "bar" => "foo",
];
?>
key может быть либо типа int, либо типа string. value может быть любого типа.

Дополнительно с ключом key будут сделаны следующие преобразования:

Строки (string), содержащие целое число (int) (исключая случаи, когда число предваряется знаком +) будут преобразованы к типу int. Например, ключ со значением "8" будет в действительности сохранён со значением 8. С другой стороны, значение "08" не будет преобразовано, так как оно не является корректным десятичным целым.
Числа с плавающей точкой (float) также будут преобразованы к типу int, то есть дробная часть будет отброшена. Например, ключ со значением 8.7 будет в действительности сохранён со значением 8.
Тип bool также преобразовываются к типу int. Например, ключ со значением true будет сохранён со значением 1 и ключ со значением false будет сохранён со значением 0.
Тип null будет преобразован к пустой строке. Например, ключ со значением null будет в действительности сохранён со значением "".
Массивы (array) и объекты (object) не могут использоваться в качестве ключей. При подобном использовании будет генерироваться предупреждение: Недопустимый тип смещения (Illegal offset type).
Если несколько элементов в объявлении массива используют одинаковый ключ, то только последний будет использоваться, а все другие будут перезаписаны.

Пример #2 Пример преобразования типов и перезаписи элементов

<?php
$array = array(
    1    => "a",
    "1"  => "b",
    1.5  => "c",
    true => "d",
);
var_dump($array);
?>
Результат выполнения данного примера:

array(1) {
  [1]=>
  string(1) "d"
}
Так как все ключи в вышеприведённом примере преобразуются к 1, значение будет перезаписано на каждый новый элемент и останется только последнее присвоенное значение "d".

Массивы в PHP могут содержать ключи типов int и string одновременно, так как PHP не делает различия между индексированными и ассоциативными массивами.

Пример #3 Смешанные ключи типов int и string

<?php
$array = array(
    "foo" => "bar",
    "bar" => "foo",
    100   => -100,
    -100  => 100,
);
var_dump($array);
?>
Результат выполнения данного примера:

array(4) {
  ["foo"]=>
  string(3) "bar"
  ["bar"]=>
  string(3) "foo"
  [100]=>
  int(-100)
  [-100]=>
  int(100)
}
Параметр key является необязательным. Если он не указан, PHP будет использовать предыдущее наибольшее значение ключа типа int, увеличенное на 1.

Пример #4 Индексированные массивы без ключа

<?php
$array = array("foo", "bar", "hallo", "world");
var_dump($array);
?>
Результат выполнения данного примера:

array(4) {
  [0]=>
  string(3) "foo"
  [1]=>
  string(3) "bar"
  [2]=>
  string(5) "hallo"
  [3]=>
  string(5) "world"
}
Возможно указать ключ только для некоторых элементов и пропустить для других:

Пример #5 Ключи для некоторых элементов

<?php
$array = array(
         "a",
         "b",
    6 => "c",
         "d",
);
var_dump($array);
?>
Результат выполнения данного примера:

array(4) {
  [0]=>
  string(1) "a"
  [1]=>
  string(1) "b"
  [6]=>
  string(1) "c"
  [7]=>
  string(1) "d"
}
Как вы видите последнее значение "d" было присвоено ключу 7. Это произошло потому, что самое большое значение ключа целого типа перед этим было 6.

Пример #6 Расширенный пример преобразования типов и перезаписи элементов

<?php
$array = array(
    1    => 'a',
    '1'  => 'b', // значение "b" перезапишет значение "a"
    1.5  => 'c', // значение "c" перезапишет значение "b"
    -1 => 'd',
    '01'  => 'e', // поскольку это не целочисленная строка, она НЕ перезапишет ключ для 1
    '1.5' => 'f', // поскольку это не целочисленная строка, она НЕ перезапишет ключ для 1
    true => 'g', // значение "g" перезапишет значение "c"
    false => 'h',
    '' => 'i',
    null => 'j', // значение "j" перезапишет значение "i"
    'k', // значение "k" присваивается ключу 2. Потому что самый большой целочисленный ключ до этого был 1
    2 => 'l', // значение "l" перезапишет значение "k"
);

var_dump($array);
?>
Результат выполнения данного примера:

array(7) {
  [1]=>
  string(1) "g"
  [-1]=>
  string(1) "d"
  ["01"]=>
  string(1) "e"
  ["1.5"]=>
  string(1) "f"
  [0]=>
  string(1) "h"
  [""]=>
  string(1) "j"
  [2]=>
  string(1) "l"
}
Этот пример включает все вариации преобразования ключей и перезаписи элементов

Доступ к элементам массива с помощью квадратных скобок ¶
Доступ к элементам массива может быть осуществлён с помощью синтаксиса array[key].

Пример #7 Доступ к элементам массива

<?php
$array = array(
    "foo" => "bar",
    42    => 24,
    "multi" => array(
         "dimensional" => array(
             "array" => "foo"
         )
    )
);

var_dump($array["foo"]);
var_dump($array[42]);
var_dump($array["multi"]["dimensional"]["array"]);
?>
Результат выполнения данного примера:

string(3) "bar"
int(24)
string(3) "foo"
Замечание:

До PHP 8.0.0 квадратные и фигурные скобки могли использоваться взаимозаменяемо для доступа к элементам массива (например, в примере выше $array[42] и $array{42} делали то же самое). Синтаксис фигурных скобок устарел в PHP 7.4.0 и больше не поддерживается в PHP 8.0.0.

Пример #8 Разыменование массива

<?php
function getArray() {
    return array(1, 2, 3);
}

$secondElement = getArray()[1];
?>
Замечание:

Попытка доступа к неопределённому ключу в массиве - это то же самое, что и попытка доступа к любой другой неопределённой переменной: будет сгенерирована ошибка уровня E_WARNING (ошибка уровня E_NOTICE до PHP 8.0.0), и результат будет null.

Замечание:

Массив, разыменовывающий скалярное значение, которое не является строкой (string), отдаст null. До PHP 7.4.0 не выдаётся сообщение об ошибке. Начиная с PHP 7.4.0, выдаётся ошибка E_NOTICE; с PHP 8.0.0 выдаётся ошибка E_WARNING.

Создание/модификация с помощью синтаксиса квадратных скобок ¶
Существующий массив может быть изменён путём явной установкой значений в нем.

Это выполняется присвоением значений массиву (array) с указанием в скобках ключа. Кроме того, ключ можно опустить, в результате получится пустая пара скобок ([]).

    $arr[key] = value;
    $arr[] = value;
    // key может быть int или string
    // value может быть любым значением любого типа
Если массив $arr ещё не существует или для него задано значение null или false, он будет создан. Таким образом, это ещё один способ определить массив array. Однако такой способ применять не рекомендуется, так как если переменная $arr уже содержит некоторое значение (например, значение типа string из переменной запроса), то это значение останется на месте и [] может на самом деле означать доступ к символу в строке. Лучше инициализировать переменную путём явного присваивания значения.

Замечание: Начиная с PHP 7.1.0, используя в оператор "пустой индекс" на строке, приведёт к фатальной ошибке. Ранее, в этом случае, строка молча преобразовывалась в массив.

Замечание: Начиная с PHP 8.1.0, создание нового массива с помощью значения false устарело. Создание нового массива из null и неопределённого значения по-прежнему разрешено.

Для изменения определённого значения просто присвойте новое значение элементу, используя его ключ. Если вы хотите удалить пару ключ/значение, вам необходимо использовать функцию unset().

<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // В этом месте скрипта это
                // то же самое, что и $arr[13] = 56;

$arr["x"] = 42; // Это добавляет к массиву новый
                // элемент с ключом "x"

unset($arr[5]); // Это удаляет элемент из массива

unset($arr);    // Это удаляет массив полностью
?>
Замечание:

Как уже говорилось выше, если ключ не был указан, то будет взят максимальный из существующих целочисленных (int) индексов, и новым ключом будет это максимальное значение (в крайнем случае 0) плюс 1. Если целочисленных (int) индексов ещё нет, то ключом будет 0 (ноль).

Учтите, что максимальное целое значение ключа не обязательно существует в массиве в данный момент. Оно могло просто существовать в массиве какое-то время, с тех пор как он был переиндексирован в последний раз. Следующий пример это иллюстрирует:

<?php
// Создаём простой массив.
$array = array(1, 2, 3, 4, 5);
print_r($array);

// Теперь удаляем каждый элемент, но сам массив оставляем нетронутым:
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// Добавляем элемент (обратите внимание, что новым ключом будет 5, вместо 0).
$array[] = 6;
print_r($array);

// Переиндексация:
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
Результат выполнения данного примера:

Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
Деструктуризация массива ¶
Массивы могут быть деструктурированы с помощью языковых конструкций [] (начиная с PHP 7.1.0) или list(). Эти конструкции могут быть использованы для деструктуризации массива на отдельные переменные.

<?php
$source_array = ['foo', 'bar', 'baz'];
[$foo, $bar, $baz] = $source_array;
echo $foo;    // выведет "foo"
echo $bar;    // выведет "bar"
echo $baz;    // выведет "baz"
?>
Деструктуризация массива может быть использована в конструкции foreach для деструктуризации многомерного массива во время итерации по нему.

<?php
$source_array = [
    [1, 'John'],
    [2, 'Jane'],
];
foreach ($source_array as [$id, $name]) {
    // логика работы с $id и $name
}
?>
Элементы массива будут игнорироваться, если переменная не указана. Деструктуризация массива всегда начинается с индекса 0.

<?php
$source_array = ['foo', 'bar', 'baz'];

// Присваивание элементу с индексом 2 переменной $baz
[, , $baz] = $source_array;

echo $baz;    // выведет "baz"
?>
Начиная с PHP 7.1.0, ассоциативные массивы также могут быть деструктурированы. Это позволяет легче выбирать нужный элемент в массивах с числовым индексом, так как индекс может быть указан явно.

<?php
$source_array = ['foo' => 1, 'bar' => 2, 'baz' => 3];

// Присваивание элементу с индексом 'baz' переменной $three
['baz' => $three] = $source_array;

echo $three;    // выведет 3

$source_array = ['foo', 'bar', 'baz'];

// Присваивание элементу с индексом 2 переменной $baz
[2 => $baz] = $source_array;

echo $baz;    // выведет "baz"
?>
Деструктуризация массива может быть использована для простой замены двух переменных местами.

<?php
$a = 1;
$b = 2;
[$b, $a] = [$a, $b];
echo $a;    // выведет 2
echo $b;    // выведет 1
?>
Замечание:

Оператор ... не поддерживается в присваиваниях.

Замечание:

Попытка получить доступ к ключу массива, который не был определён, аналогична обращению к любой другой неопределённой переменной: будет выдано сообщение об ошибке уровня E_WARNING (ошибка уровня E_NOTICE до PHP 8.0.0), а результатом будет null.

Полезные функции ¶
Для работы с массивами существует достаточное количество полезных функций. Смотрите раздел функции для работы с массивами.

Замечание:

Функция unset() позволяет удалять ключи массива. Обратите внимание, что массив НЕ будет переиндексирован. Если вы действительно хотите поведения в стиле "удалить и сдвинуть", можно переиндексировать массив используя array_values().

<?php
$a = array(1 => 'один', 2 => 'два', 3 => 'три');
unset($a[2]);
/* даст массив, представленный так:
   $a = array(1 => 'один', 3 => 'три');
   а НЕ так:
   $a = array(1 => 'один', 2 => 'три');
*/

$b = array_values($a);
// Теперь $b это array(0 => 'один', 1 => 'три')
?>
Управляющая конструкция foreach существует специально для массивов. Она предоставляет возможность легко пройтись по массиву.

Что можно и нельзя делать с массивами ¶
Почему $foo[bar] неверно? ¶
Всегда заключайте в кавычки строковый литерал в индексе ассоциативного массива. К примеру, пишите $foo['bar'], а не $foo[bar]. Но почему? Часто в старых скриптах можно встретить следующий синтаксис:

<?php
$foo[bar] = 'враг';
echo $foo[bar];
// и т.д.
?>
Это неверно, хотя и работает. Причина в том, что этот код содержит неопределённую константу (bar), а не строку ('bar' - обратите внимание на кавычки). Это работает, потому что PHP автоматически преобразует "голую строку" (не заключённую в кавычки строку, которая не соответствует ни одному из известных символов языка) в строку со значением этой "голой строки". Например, если константа с именем bar не определена, то PHP заменит bar на строку 'bar' и использует её.

Внимание
Резервный вариант для обработки неопределённой константы как пустой строки вызывает ошибку уровня E_NOTICE. Начиная с PHP 7.2.0 поведение объявлено устаревшим и вызывает ошибку уровня E_WARNING. Начиная с PHP 8.0.0, удалено и выбрасывает исключение Error.

Замечание: Это не означает, что нужно всегда заключать ключ в кавычки. Нет необходимости заключать в кавычки константы или переменные, поскольку это помешает PHP обрабатывать их.

<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Простой массив:
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nПроверяем $i: \n";
    echo "Плохо: " . $array['$i'] . "\n";
    echo "Хорошо: " . $array[$i] . "\n";
    echo "Плохо: {$array['$i']}\n";
    echo "Хорошо: {$array[$i]}\n";
}
?>
Результат выполнения данного примера:

Проверяем 0:
Notice: Undefined index:  $i in /path/to/script.html on line 9
Плохо:
Хорошо: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Плохо:
Хорошо: 1

Проверяем 1:
Notice: Undefined index:  $i in /path/to/script.html on line 9
Плохо:
Хорошо: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Плохо:
Хорошо: 2
Дополнительные примеры, демонстрирующие этот факт:

<?php
// Показываем все ошибки
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// Верно
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// Неверно. Это работает, но из-за неопределённой константы с
// именем fruit также вызывает ошибку PHP уровня E_NOTICE
//
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// Давайте определим константу, чтобы продемонстрировать, что
// происходит. Мы присвоим константе с именем fruit значение 'veggie'.
define('fruit', 'veggie');

// Теперь обратите внимание на разницу
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// Внутри строки это нормально. Внутри строк константы не
// рассматриваются, так что ошибки E_NOTICE здесь не произойдёт
print "Hello $arr[fruit]";      // Hello apple

// С одним исключением: фигурные скобки вокруг массивов внутри
// строк позволяют константам там находиться
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// Это не будет работать и вызовет ошибку обработки, такую как:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Это, конечно, также действует и с суперглобальными переменными в строках
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";

// Ещё одна возможность - конкатенация
print "Hello " . $arr['fruit']; // Hello apple
?>
Если вы переведёте error_reporting в режим отображения ошибок уровня E_NOTICE (например, такой как E_ALL), вы сразу увидите эти ошибки. По умолчанию error_reporting установлена их не отображать.

Как указано в разделе синтаксис, внутри квадратных скобок ('[' и ']') должно быть выражение. Это означает, что можно писать вот так:

<?php
echo $arr[somefunc($bar)];
?>
Это пример использования возвращаемого функцией значения в качестве индекса массива. PHP известны также и константы:

<?php
$error_descriptions[E_ERROR]   = "Произошла фатальная ошибка";
$error_descriptions[E_WARNING] = "PHP сообщает о предупреждении";
$error_descriptions[E_NOTICE]  = "Это лишь неофициальное замечание";
?>
Обратите внимание, что E_ERROR - это такой же верный идентификатор, как и bar в первом примере. Но последний пример по сути эквивалентен такой записи:

<?php
$error_descriptions[1] = "Произошла фатальная ошибка";
$error_descriptions[2] = "PHP сообщает о предупреждении";
$error_descriptions[8] = "Это лишь неофициальное замечание";
?>
поскольку E_ERROR соответствует 1 и т.д.

Так что же в этом плохого?
Когда-нибудь в будущем команда разработчиков PHP возможно пожелает добавить ещё одну константу или ключевое слово, либо константа из другого кода может вмешаться и тогда у вас могут возникнуть проблемы. Например, вы уже не можете использовать таким образом слова empty и default, поскольку они являются зарезервированными ключевыми словами.

Замечание: Повторим, внутри строки (string), заключённой в двойные кавычки, корректно не окружать индексы массива кавычками, поэтому "$foo[bar]" является верной записью. Более подробно почему - смотрите вышеприведённые примеры, а также раздел по обработке переменных в строках.

Преобразование в массив ¶
Для любого из типов int, float, string, bool и resource, преобразование значения в массив даёт результатом массив с одним элементом (с индексом 0), являющимся скалярным значением, с которого вы начали. Другими словами, (array)$scalarValue - это точно то же самое, что и array($scalarValue).

Если вы преобразуете в массив объект (object), вы получите в качестве элементов массива свойства (переменные-члены) этого объекта. Ключами будут имена переменных-членов, с некоторыми примечательными исключениями: целочисленные свойства станут недоступны; к закрытым полям класса (private) спереди будет дописано имя класса; к защищённым полям класса (protected) спереди будет добавлен символ '*'. Эти добавленные значения с обоих сторон также имеют NUL байты. Неинициализированные типизированные свойства автоматически отбрасываются.

<?php
class A {
    private $B;
    protected $C;
    public $D;
    function __construct()
    {
        $this->{1} = null;
    }
}
var_export((array) new A());
?>
Результат выполнения данного примера:

array (
  '' . "\0" . 'A' . "\0" . 'B' => NULL,
  '' . "\0" . '*' . "\0" . 'C' => NULL,
  'D' => NULL,
  1 => NULL,
)
Это может вызвать несколько неожиданное поведение:

<?php
class A {
    private $A; // Это станет '\0A\0A'
}
class B extends A {
    private $A; // Это станет '\0B\0A'
    public $AA; // Это станет 'AA'
}
var_dump((array) new B());
?>
Результат выполнения данного примера:

array(3) {
  ["BA"]=>
  NULL
  ["AA"]=>
  NULL
  ["AA"]=>
  NULL
}
Вышеприведённый код покажет 2 ключа с именем 'AA', хотя один из них на самом деле имеет имя '\0A\0A'.

Если вы преобразуете в массив значение null, вы получите пустой массив.

Сравнение ¶
Массивы можно сравнивать при помощи функции array_diff() и операторов массивов.

Распаковка массива ¶
Массив с префиксом ... будет распакован во время определения массива. Только массивы и объекты, которые реализуют интерфейс Traversable, могут быть распакованы. Распаковка массива с помощью ... доступна, начиная с PHP 7.4.0.

Массив можно распаковывать несколько раз и добавлять обычные элементы до или после оператора ...:

Пример #9 Простая распаковка массива

<?php
// Использование короткого синтаксиса массива.
// Также работает с синтаксисом array().
$arr1 = [1, 2, 3];
$arr2 = [...$arr1]; // [1, 2, 3]
$arr3 = [0, ...$arr1]; // [0, 1, 2, 3]
$arr4 = [...$arr1, ...$arr2, 111]; // [1, 2, 3, 1, 2, 3, 111]
$arr5 = [...$arr1, ...$arr1]; // [1, 2, 3, 1, 2, 3]
function getArr() {
  return ['a', 'b'];
}
$arr6 = [...getArr(), 'c' => 'd']; // ['a', 'b', 'c' => 'd']
?>
Распаковка массива с помощью оператора ... следует семантике функции array_merge(). То есть более поздние строковые ключи перезаписывают более ранние, а целочисленные ключи перенумеровываются:

Пример #10 Распаковка массива с дублирующим ключом

<?php
// строковый ключ
$arr1 = ["a" => 1];
$arr2 = ["a" => 2];
$arr3 = ["a" => 0, ...$arr1, ...$arr2];
var_dump($arr3); // ["a" => 2]
// целочисленный ключ
$arr4 = [1, 2, 3];
$arr5 = [4, 5, 6];
$arr6 = [...$arr4, ...$arr5];
var_dump($arr6); // [1, 2, 3, 4, 5, 6]
// Который [0 => 1, 1 => 2, 2 => 3, 3 => 4, 4 => 5, 5 => 6]
// где исходные целочисленные ключи не были сохранены.
?>
Замечание:

Ключи, которые не являются ни целыми числами, ни строками, вызывают ошибку TypeError. Такие ключи могут быть сгенерированы только объектом Traversable.

Замечание:

До PHP 8.1 распаковка массива со строковым ключом не поддерживалась:

<?php
$arr1 = [1, 2, 3];
$arr2 = ['a' => 4];
$arr3 = [...$arr1, ...$arr2];
// Ошибка: невозможно распаковать массив со строковыми ключами в example.php:5
$arr4 = [1, 2, 3];
$arr5 = [4, 5];
$arr6 = [...$arr4, ...$arr5]; // работает. [1, 2, 3, 4, 5]
?>
Примеры ¶
Тип массив в PHP является очень гибким, вот несколько примеров:

<?php
// это
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
            4        // ключом будет 0
          );

$b = array('a', 'b', 'c');

// . . .полностью соответствует
$a = array();
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // ключом будет 0

$b = array();
$b[] = 'a';
$b[] = 'b';
$b[] = 'c';

// после выполнения этого кода, $a будет массивом
// array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round',
// 'name' => 'apple', 0 => 4), а $b будет
// array(0 => 'a', 1 => 'b', 2 => 'c'), или просто array('a', 'b', 'c').
?>
Пример #11 Использование array()

<?php
// Массив как карта (свойств)
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );

// исключительно числовые ключи
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// это то же самое, что и array(0 => 7, 1 => 8, ...)

$switching = array(         10, // ключ = 0
                    5    =>  6,
                    3    =>  7,
                    'a'  =>  4,
                            11, // ключ = 6 (максимальным числовым индексом было 5)
                    '8'  =>  2, // ключ = 8 (число!)
                    '02' => 77, // ключ = '02'
                    0    => 12  // значение 10 будет перезаписано на 12
                  );

// пустой массив
$empty = array();
?>
Пример #12 Коллекция

<?php
$colors = array('red', 'blue', 'green', 'yellow');

foreach ($colors as $color) {
    echo "Вам нравится $color?\n";
}

?>
Результат выполнения данного примера:

Вам нравится red?
Вам нравится blue?
Вам нравится green?
Вам нравится yellow?
Изменение значений массива напрямую возможно путём передачи их по ссылке.

Пример #13 Изменение элемента в цикле

<?php
foreach ($colors as &$color) {
    $color = strtoupper($color);
}
unset($color); /* это нужно для того, чтобы последующие записи в
$color не меняли последний элемент массива */

print_r($colors);
?>
Результат выполнения данного примера:

Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
Следующий пример создаёт массив, начинающийся с единицы.

Пример #14 Индекс, начинающийся с единицы

<?php
$firstquarter  = array(1 => 'Январь', 'Февраль', 'Март');
print_r($firstquarter);
?>
Результат выполнения данного примера:

Array
(
    [1] => 'Январь'
    [2] => 'Февраль'
    [3] => 'Март'
)
Пример #15 Заполнение массива

<?php
// заполняем массив всеми элементами из директории
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle);
?>
Массивы упорядочены. Вы можете изменять порядок элементов, используя различные функции сортировки. Для дополнительной информации смотрите раздел функции для работы с массивами. Вы можете подсчитать количество элементов в массиве с помощью функции count().

Пример #16 Сортировка массива

<?php
sort($files);
print_r($files);
?>
Поскольку значение массива может быть чем угодно, им также может быть другой массив. Таким образом вы можете создавать рекурсивные и многомерные массивы.

Пример #17 Рекурсивные и многомерные массивы

<?php
$fruits = array ( "fruits"  => array ( "a" => "апельсин",
                                       "b" => "банан",
                                       "c" => "яблоко"
                                     ),
                  "numbers"   => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "holes"   => array (      "первая",
                                       5 => "вторая",
                                            "третья"
                                     )
                );

// Несколько примеров доступа к значениям предыдущего массива
echo $fruits["holes"][5];    // напечатает "вторая"
echo $fruits["fruits"]["a"]; // напечатает "апельсин"
unset($fruits["holes"][0]);  // удалит "первая"

// Создаст новый многомерный массив
$juices["apple"]["green"] = "good";
?>
Обратите внимание, что при присваивании массива всегда происходит копирование значения. Чтобы скопировать массив по ссылке, вам нужно использовать оператор ссылки.

<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 изменился,
             // $arr1 всё ещё array(2, 3)

$arr3 = &$arr1;
$arr3[] = 4; // теперь $arr1 и $arr3 одинаковы
?>
＋add a note
User Contributed Notes 20 notes
up
down
121mlvljr ¶11 years ago
please note that when arrays are copied, the "reference status" of their members is preserved (http://www.php.net/manual/en/language.references.whatdo.php).
up
down
67thomas tulinsky ¶6 years ago
I think your first, main example is needlessly confusing, very confusing to newbies:

$array = array(
    "foo" => "bar",
    "bar" => "foo",
);

It should be removed.

For newbies:
An array index can be any string value, even a value that is also a value in the array.
The value of array["foo"] is "bar".
The value of array["bar"] is "foo"

The following expressions are both true:
$array["foo"] == "bar"
$array["bar"] == "foo"
up
down
36liberchen at gmail dot com ¶4 years ago
Since PHP 7.1, the string will not be converted to array automatically.

Below codes will fail:

$a=array();
$a['a']='';
$a['a']['b']=''; 
//Warning: Illegal string offset 'b'
//Warning: Cannot assign an empty string to a string offset

You have to change to as below:

$a=array();

$a['a']=array(); // Declare it is an array first
$a['a']['b']='';
up
down
56ken underscore yap atsign email dot com ¶14 years ago
"If you convert a NULL value to an array, you get an empty array."

This turns out to be a useful property. Say you have a search function that returns an array of values on success or NULL if nothing found.

<?php $values = search(...); ?>

Now you want to merge the array with another array. What do we do if $values is NULL? No problem:

<?php $combined = array_merge((array)$values, $other); ?>

Voila.
up
down
54jeff splat codedread splot com ¶17 years ago
Beware that if you're using strings as indices in the $_POST array, that periods are transformed into underscores:

<html>
<body>
<?php
    printf("POST: "); print_r($_POST); printf("<br/>");
?>
<form method="post" action="<?php echo $_SERVER['PHP_SELF']; ?>">
    <input type="hidden" name="Windows3.1" value="Sux">
    <input type="submit" value="Click" />
</form>
</body>
</html>

Once you click on the button, the page displays the following:

POST: Array ( [Windows3_1] => Sux )
up
down
29Yesterday php&#39;er ¶5 years ago
--- quote ---
Note:
Both square brackets and curly braces can be used interchangeably for accessing array elements
--- quote end ---

At least for php 5.4 and 5.6; if function returns an array, the curly brackets does not work directly accessing function result, eg. WillReturnArray(){1} . This will give "syntax error, unexpected '{' in...".
Personally I use only square brackets, expect for accessing single char in string. Old habits...
up
down
40chris at ocportal dot com ¶9 years ago
Note that array value buckets are reference-safe, even through serialization.

<?php
$x='initial';
$test=array('A'=>&$x,'B'=>&$x);
$test=unserialize(serialize($test));
$test['A']='changed';
echo $test['B']; // Outputs "changed"
?>

This can be useful in some cases, for example saving RAM within complex structures.
up
down
38ia [AT] zoznam [DOT] sk ¶17 years ago
Regarding the previous comment, beware of the fact that reference to the last value of the array remains stored in $value after the foreach:

<?php
foreach ( $arr as $key => &$value )
{
    $value = 1;
}

// without next line you can get bad results...
//unset( $value );

$value = 159;
?>

Now the last element of $arr has the value of '159'. If we remove the comment in the unset() line, everything works as expected ($arr has all values of '1').

Bad results can also appear in nested foreach loops (the same reason as above).

So either unset $value after each foreach or better use the longer form:

<?php
foreach ( $arr as $key => $value )
{
    $arr[ $key ] = 1;
}
?>
up
down
4phplatino at gmail dot com ¶1 year ago
to know the depth (dimension) of a ARRAY, you can use this:

function Dim_Ar($A, $i){
    if(!is_array($A))return 0;
    $t[] = 1;
    foreach($A AS $e)if(is_array($e))$t[] = Dim_Ar($e, ++ $i) + 1;
    return max($t);
    }

and use with:

$Q = ARRAY(ARRAY(ARRAY()), ARRAY(ARRAY()));// here depth/dimension is three

echo Dim_Ar($Q, 0);
up
down
11anisgazig at gmail dot com ¶3 years ago
//array keys are always integer and string data type and array values are all data type
//type casting and overwriting(data type of array key)
//----------------------------------------------------
$arr = array(
1=>"a",//int(1)
"3"=>"b",//int(3)
"08"=>"c",//string(2)"08"
"80"=>"d",//int(80)
"0"=>"e",//int(0)
"Hellow"=>"f",//string(6)"Hellow"
"10Hellow"=>"h",//string(8)"10Hellow"
1.5=>"j",//int(1.5)
"1.5"=>"k",//string(3)"1.5"
0.0=>"l",//int(0)
false=>"m",//int(false)
true=>"n",//int(true)
"true"=>"o",//string(4)"true"
"false"=>"p",//string(5)"false"
null=>"q",//string(0)""
NULL=>"r",//string(0)"" note null and NULL are same
"NULL"=>"s",//string(4)"NULL" ,,,In last element of multiline array,comma is better to used.
);
//check the data type name of key
foreach ($arr as $key => $value) {
var_dump($key);
echo "<br>";
}

//NOte :array and object data type in keys are Illegal ofset.......